(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{418:function(t,r,a){"use strict";a.r(r);var v=a(1),s=Object(v.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"list"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[t._v("#")]),t._v(" List")]),t._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://lxzxz-club-myblog.oss-cn-guangzhou.aliyuncs.com/20230515151714.png"}}),t._v(" "),r("h2",{attrs:{id:"list-set-queue-map-四者的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#list-set-queue-map-四者的区别"}},[t._v("#")]),t._v(" List, Set, Queue, Map 四者的区别?")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("List(对付顺序的好帮手)")]),t._v(":存储的元素是有序的、可重复的。")]),t._v(" "),r("li",[r("strong",[t._v("Set (注重独一无二的性质)")]),t._v(":存储的元素是无序的、不可重复的。")]),t._v(" "),r("li",[r("strong",[t._v("Queue(实现排队功能的叫号机)")]),t._v("：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。")]),t._v(" "),r("li",[r("strong",[t._v("Map（用key来搜索的专家)")]),t._v('：使用键值对（key-value）存储，类似于数学上的函数y=f(x)，"x"代表key，"y"代表value，key是无序的、不可重复的，value是无序的、可重复的，每个键最多映射到一个值。')])]),t._v(" "),r("h2",{attrs:{id:"如何选用集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何选用集合"}},[t._v("#")]),t._v(" "),r("strong",[t._v("如何选用集合?")])]),t._v(" "),r("p",[t._v("主要根据集合的特点来选用，")]),t._v(" "),r("p",[t._v("比如我们需要"),r("strong",[t._v("根据键值")]),t._v("获取到元素值时就选用"),r("strong",[t._v("Map")]),t._v(" 接口下的集合，")]),t._v(" "),r("p",[t._v("需要"),r("strong",[t._v("排序")]),t._v("时选择 TreeMap,")]),t._v(" "),r("p",[t._v("不需要"),r("strong",[t._v("排序")]),t._v("时就选择 HashMap,")]),t._v(" "),r("p",[t._v("需要"),r("strong",[t._v("保证线程安全")]),t._v("就选用 ConcurrentHashMap。")]),t._v(" "),r("p",[t._v("当我们"),r("strong",[t._v("只需要存放元素值时")]),t._v("，就选择实现"),r("strong",[t._v("Collection")]),t._v(" 接口的集合，")]),t._v(" "),r("p",[t._v("需要"),r("strong",[t._v("保证元素唯一")]),t._v("时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，")]),t._v(" "),r("p",[t._v("不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，然后再根据实现这些接口的集合的特点来选用。")]),t._v(" "),r("p",[t._v("Linkedlist增删效率高，查询慢")]),t._v(" "),r("p",[t._v("ArrayList查询快，增删慢，如果增删最后一个效率也高")]),t._v(" "),r("h2",{attrs:{id:"对list的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对list的理解"}},[t._v("#")]),t._v(" "),r("strong",[t._v("对list的理解")])]),t._v(" "),r("p",[t._v("List在java里面是一个接口，常见的实现类有ArrayList和linkedList,在开发中用的最多得是ArrayList")]),t._v(" "),r("p",[t._v("ArrayList底层数据结构是数组，LinkedList底层数据结构是双向链表")]),t._v(" "),r("h2",{attrs:{id:"如何实现数组和-list-之间的转换"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何实现数组和-list-之间的转换"}},[t._v("#")]),t._v(" "),r("strong",[t._v("如何实现数组和 List 之间的转换？")])]),t._v(" "),r("p",[t._v("List转换成数组：调用ArrayList的toArray方法。")]),t._v(" "),r("p",[t._v("数组转换成为List：调用Arrays的asList方法。")]),t._v(" "),r("h2",{attrs:{id:"array-和-arraylist-有何区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#array-和-arraylist-有何区别"}},[t._v("#")]),t._v(" "),r("strong",[t._v("Array 和 ArrayList 有何区别？")])]),t._v(" "),r("p",[t._v("Array可以容纳基本类型和引用类型，而ArrayList只能容纳引用类型。")]),t._v(" "),r("p",[t._v("如果给List装int，会自动装箱成Integer")]),t._v(" "),r("p",[t._v("Array是指定大小的，而ArrayList大小是固定的，可扩容。")]),t._v(" "),r("h2",{attrs:{id:"java本身有数组为什么要用arraylist-中间增删效率低-查询快"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java本身有数组为什么要用arraylist-中间增删效率低-查询快"}},[t._v("#")]),t._v(" "),r("strong",[t._v("java本身有数组为什么要用ArrayList（中间增删效率低，查询快）")])]),t._v(" "),r("p",[t._v("自带的数组，在创建时候必须要为它创建大小，是固定的，但是在日常的开发中，往往不知道给数组分配多大")]),t._v(" "),r("p",[r("strong",[t._v("new")])]),t._v(" "),r("p",[t._v("ArrayList是动态扩容的，当new ArrayList()的时候，默认有一个空的Object数组，大小为0")]),t._v(" "),r("p",[r("strong",[t._v("add O(1)")])]),t._v(" "),r("p",[t._v("第一次添加数据时候，会给这个数组初始化大小为10，使用ArrayList在每一次add时候，会先计算数组够不够空间，")]),t._v(" "),r("p",[t._v("如果空间够，就直接追加")]),t._v(" "),r("p",[t._v("如果不够，就扩容1.5倍 int newCapacity = oldCapacity + (oldCapacity >> 1);")]),t._v(" "),r("p",[t._v("Arrays.copyOf()底层调用的是System.arrayCopy()")]),t._v(" "),r("h2",{attrs:{id:"怎么扩容"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#怎么扩容"}},[t._v("#")]),t._v(" "),r("strong",[t._v("怎么扩容？")])]),t._v(" "),r("p",[t._v("使用grow方法，每一次扩大原来的1.5倍（新建一个1.5倍大小的组数），如果扩容后大小还是不够，将数组大小直接设置为我们需要的大小，")]),t._v(" "),r("p",[t._v("空间扩容之后，会调用Arrays.copyOf对旧数组进行拷贝")]),t._v(" "),r("h2",{attrs:{id:"为什么日常中使用最多的是arraylist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么日常中使用最多的是arraylist"}},[t._v("#")]),t._v(" "),r("strong",[t._v("为什么日常中使用最多的是ArrayList？")])]),t._v(" "),r("p",[t._v("遍历查找的需求比增删多，即使是增删也是在ArrayList的尾部添加元素就ok，尾部添加元素是O(1)")]),t._v(" "),r("p",[r("strong",[t._v("remove O(n）")])]),t._v(" "),r("p",[t._v("将删除位置后的元素向前移动，也是调用的System.arrayCopy()方法，复制完成后，将数组元素的最后一个设置为null，解决复制之后重复元素的问题。")]),t._v(" "),r("h2",{attrs:{id:"arraylist集合加入1万条数据-应该怎么提高效率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#arraylist集合加入1万条数据-应该怎么提高效率"}},[t._v("#")]),t._v(" "),r("strong",[t._v("ArrayList集合加⼊1万条数据，应该怎么提⾼效率")])]),t._v(" "),r("p",[t._v("默认容量为10，会不断扩容，影响效率，如果知道了1万条数据，只需要在初始化的时候设置相应的容量大小就行了")]),t._v(" "),r("p",[t._v("-------------------------------------------------")]),t._v(" "),r("h2",{attrs:{id:"linkedlist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[t._v("#")]),t._v(" "),r("strong",[t._v("LinkedList")])]),t._v(" "),r("p",[t._v("底层是双向链表，适合增删，不适合查找")]),t._v(" "),r("p",[t._v("这种链式存储方式与数组的连续存储方式相比，内存的利用率更高")]),t._v(" "),r("p",[t._v("提供从头添加和从尾添加的方法，节点删除也提供了从头删除和从尾删除的方法")]),t._v(" "),r("p",[t._v("实现了Deque接口，可以像操作队列和栈一样")]),t._v(" "),r("p",[t._v("有序可重复")]),t._v(" "),r("p",[t._v("允许为空")]),t._v(" "),r("p",[t._v("非线程安全")]),t._v(" "),r("p",[t._v("-----------------------------------")]),t._v(" "),r("h2",{attrs:{id:"vector"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vector"}},[t._v("#")]),t._v(" "),r("strong",[t._v("Vector")])]),t._v(" "),r("p",[t._v("vector底层是数组，一般很少使用")]),t._v(" "),r("p",[t._v("相比于ArrayList，是线程安全的，在扩容的时候直接扩容2倍，消耗的内存更大")]),t._v(" "),r("p",[t._v("可以用Collections将ArrayList变成线程安全的")]),t._v(" "),r("p",[t._v("-------------------------------------------------")]),t._v(" "),r("h2",{attrs:{id:"线程安全的list还有哪一些-copyonwritearraylist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程安全的list还有哪一些-copyonwritearraylist"}},[t._v("#")]),t._v(" "),r("strong",[t._v("线程安全的List还有哪一些？CopyOnWriteArrayList")])]),t._v(" "),r("p",[t._v("在java.util.concurrent 还有一个类：CopyOnWriteArrayList")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("先说说copy-on-write（简称cow）意思\n在Linux中，所有进程都是init进程fork出来的\n除了进程号之外，fork出来的子进程，和父进程是一模一样的\n当使用cow机制，子进程在被fork之后，exec之前，两个进程使用的是相同的内存空间的\n意味着子进程的代码段、数据段、堆栈都是指向父进程的物理空间\n当父子进程有更改的行为发生时候，再为子进程分配相应物理空间\n这样做的好处是：等到真正发生修改的时候，采取分配资源，可以减少分配或者复制大量资源时候带来的瞬间延时\n简单来说，可以理解为懒加载，或者单例模式的懒汉式，等真正使用的时候在分配\n\n在文件系统中，也有cow的机制\n文件系统的cow在修改数据的时候，不会在原来的数据位置上进行操作，而是重新找个位置修改\n比如：修改A的内容，先把A读出来，写到B里面，\n如果这时候断电了，原来A的内容还在，可以保证数据的完整性，容易恢复\n")])])]),r("p",[t._v("CopyOnWriteArrayList是一个线程安全的List，底层是通过复制数组的方式来实现的")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("get方法")]),t._v(" "),r("ul",[r("li",[t._v("​\t不加锁")])])]),t._v(" "),r("li",[r("p",[t._v("add()方法")]),t._v(" "),r("ul",[r("li",[t._v("加一个lock锁，然后复制出一个新的数组，往新的数组添加元素，最后把array的指向变为新的数组")])])]),t._v(" "),r("li",[r("p",[t._v("get()和size()")]),t._v(" "),r("ul",[r("li",[t._v("只是获取array指向的数组的元素或者大小")])])])]),t._v(" "),r("p",[t._v("CopyOnWriteArrayList和文件系统的COW机制很像")]),t._v(" "),r("p",[t._v("读读不互斥，读写不互斥")]),t._v(" "),r("h2",{attrs:{id:"copyonwritearraylist的缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#copyonwritearraylist的缺点"}},[t._v("#")]),t._v(" "),r("strong",[t._v("CopyOnWriteArrayList的缺点？")])]),t._v(" "),r("p",[t._v("比较消耗内存，每次调用add()方法都会复制一个数组出来")]),t._v(" "),r("p",[t._v("CopyOnWriteArrayList只能保证数据的最终一致性，不能保证数据的实时一致性")]),t._v(" "),r("p",[t._v("假设两个线程，线程A读取CopyOnWriteArrayList的数据，还没读取完")]),t._v(" "),r("p",[t._v("这时线程B把CopyOnWriteArrayList数据清空了，线程A还是可以把剩余的数据读出来。")])])}),[],!1,null,null,null);r.default=s.exports}}]);