(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{421:function(v,_,t){"use strict";t.r(_);var a=t(1),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"hotspot虚拟机的对象创建、布局、定位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hotspot虚拟机的对象创建、布局、定位"}},[v._v("#")]),v._v(" HotSpot虚拟机的对象创建、布局、定位")]),v._v(" "),_("h2",{attrs:{id:"对象创建"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象创建"}},[v._v("#")]),v._v(" 对象创建")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://lxzxz-club-myblog.oss-cn-guangzhou.aliyuncs.com/20230515152317.png",alt:""}})]),v._v(" "),_("p",[v._v("1、当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，")]),v._v(" "),_("p",[v._v("并且检查这个符号引用代表的类是否已被加载过。（简单点儿说，首先检查对应的类是否被加载过）（实例化）")]),v._v(" "),_("p",[v._v("如果没有，那必须先执行相应的类加载过程，")]),v._v(" "),_("p",[v._v("1)加载 -> 2)验证 -> 3)准备 -> 4)解析 -> 5)初始化")]),v._v(" "),_("p",[v._v("2、类加载通过后，为新生对象分配内存，（在堆上）")]),v._v(" "),_("ul",[_("li",[v._v("​    分配方式有“"),_("strong",[v._v("指针碰撞")]),v._v("”和“"),_("strong",[v._v("空闲列表")]),v._v("”两种，选择哪种分配方式由Java 堆是否规整决定，而Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。")])]),v._v(" "),_("p",[v._v("3、将分配到的内存空间（但不包括对象头）都初始化为零值(默认值)，保证不赋值就能使用")]),v._v(" "),_("p",[v._v("4、设置对象头（1、markword，2、类型指针）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("​    初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的")])]),v._v(" "),_("li",[_("p",[v._v("​    GC分代年龄等信息。  这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。")])])]),v._v(" "),_("p",[v._v("5、之后执行构造函数，进行对象的初始化，完成对象的创建 ，执行ini方法")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"对象的内存布局-组成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象的内存布局-组成"}},[v._v("#")]),v._v(" 对象的内存布局（组成）")]),v._v(" "),_("p",[v._v("总结：")]),v._v(" "),_("p",[v._v("对象在堆内存中的存储布局可以划分为三个部分：")]),v._v(" "),_("p",[_("strong",[v._v("一、对象头（Header）：MarkWord和类型指针")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("1 MarkWord 用于存储对象自身的运行时数据")])])]),v._v(" "),_("p",[v._v("​\tMark Word是一个有着动态定义的数据结构")]),v._v(" "),_("p",[v._v("​\t如：包括哈希码，GC分代年龄，线程持有的锁，偏向线程Id，偏向时间戳等")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://lxzxz-club-myblog.oss-cn-guangzhou.aliyuncs.com/20230515152326.png",alt:""}})]),v._v(" "),_("ul",[_("li",[v._v("2 类型指针")])]),v._v(" "),_("p",[v._v("​\t\t确定该对象是哪个类的实例，")]),v._v(" "),_("p",[v._v("​\t\t如果对象是java数组，那么在对象头还要有一块记录数组长度的数据")]),v._v(" "),_("p",[_("strong",[v._v("二、实例数据（Instance Data）")])]),v._v(" "),_("p",[v._v("对象真正存储的有效信息，我们在程序代码里面所定义的各种类型的字段内容")]),v._v(" "),_("p",[_("strong",[v._v("三、对齐填充（Padding）")])]),v._v(" "),_("p",[v._v("HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，")]),v._v(" "),_("p",[v._v("因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。")]),v._v(" "),_("p",[v._v("非必须有")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"对象的访问定位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象的访问定位"}},[v._v("#")]),v._v(" 对象的访问定位")]),v._v(" "),_("p",[v._v("建立对象就是为了使用对象，我们的 Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有"),_("strong",[v._v("①使用句柄")]),v._v("和"),_("strong",[v._v("②直接指针")]),v._v("两种：")]),v._v(" "),_("p",[_("strong",[v._v("1.句柄")]),v._v("：如果使用句柄的话，那么Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；")]),v._v(" "),_("p",[_("strong",[v._v("2.直接指针")]),v._v("：如果使用直接指针访问，那么Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。")]),v._v(" "),_("p",[v._v("这两种对象访问方式各有优势。")]),v._v(" "),_("p",[v._v("​\t使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，")]),v._v(" "),_("p",[v._v("​\t而 reference 本身不需要修改。 使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。")])])}),[],!1,null,null,null);_.default=r.exports}}]);