(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{422:function(a,t,v){"use strict";v.r(t);var s=v(1),_=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"类加载机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载机制"}},[a._v("#")]),a._v(" 类加载机制")]),a._v(" "),t("h2",{attrs:{id:"类加载机制-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载机制-2"}},[a._v("#")]),a._v(" "),t("strong",[a._v("类加载机制：")])]),a._v(" "),t("p",[a._v("​\tJava虚拟机把描述类的数据从Class文件加载到内存，")]),a._v(" "),t("p",[a._v("​\t并对数据进行校验、转换解析和初始化，")]),a._v(" "),t("p",[a._v("​\t最终形成可以被虚拟机直接使用的Java类型的这个过程")]),a._v(" "),t("h2",{attrs:{id:"类加载机制过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载机制过程"}},[a._v("#")]),a._v(" "),t("strong",[a._v("类加载机制过程：")])]),a._v(" "),t("p",[a._v("一个类型从被加载到虚拟机内存中开始，到卸载出内存为止会有七个阶段：")]),a._v(" "),t("p",[a._v("1、加载（Loading）")]),a._v(" "),t("p",[a._v("2、验证（Verification） 3、 准备（Preparation） 4、解析（Resolution）、  （2-4这三个被称为连接）")]),a._v(" "),t("p",[a._v("5、初始化（Initialization） 6、使用（Using） 7、卸载（Unloading）")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://lxzxz-club-myblog.oss-cn-guangzhou.aliyuncs.com/20230515152421.png",alt:""}})]),a._v(" "),t("p",[t("strong",[a._v("一、加载")]),a._v("\n1）通过全限定类名获取对应的二进制字节流。\n2）将这个字节流所转化为方法区的运行时数据结构。\n3）在内存中生成Class对象，作为方法区中这个类的各种数据的访问入口。")]),a._v(" "),t("p",[t("strong",[a._v("二、验证")]),a._v("\n确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，\n保证这些信息被当作代码运行后不会危害虚拟机自身的安全。\n（有文件格式验证、元数据验证、字节码验证、符号引用验证，我面试从没被问过具体的这几个阶段）")]),a._v(" "),t("p",[t("strong",[a._v("三、准备")]),a._v("\n为类变量（即静态变量，被static修饰的变量，不包括实例变量）分配内存并设置类变量初始值的阶段\n（初始值！就是0，false，null那种，初始化阶段才是我们程序员写的值，谨记）\n如果是有final修饰例外， 直接赋予我们写的值\n**例子1：**public static int value = 123;\n那变量value在准备阶段过后的初始值为0而不是123\n**例子2：**public static final int value = 123;\n在准备阶段虚拟机就会根据Con-stantValue的设置将value赋值为123")]),a._v(" "),t("p",[t("strong",[a._v("四、解析")]),a._v("\n解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类和接口，字段、方法和接口方法、方法类型等\n"),t("strong",[a._v("符号引用：")]),a._v("\n是以一组符号来描述所引用的目标，它是编译原理方面的概念，有被模块到处或者开放的包，类和接口的全限定名，字段的名称和描述符，方法的名称和描述符，方法的句柄和方法类型，动态调用点和动态常量\n"),t("strong",[a._v("直接引用")]),a._v("\n是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄")]),a._v(" "),t("p",[t("strong",[a._v("五、初始化")]),a._v("\n直到初始化阶段，Java虚拟机才真正开始执行类中编写的\nJava程序代码，\n会收集所有为类变量赋值和静态语句块中的代码语句，为这些静态变量赋值")]),a._v(" "),t("h2",{attrs:{id:"类加载的触发条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载的触发条件"}},[a._v("#")]),a._v(" "),t("strong",[a._v("类加载的触发条件")])]),a._v(" "),t("p",[a._v("1 使用new关键字实例化对象的时候")]),a._v(" "),t("p",[a._v("2 读取或设置一个类型的静态字段")]),a._v(" "),t("p",[a._v("3 调用一个类型的静态方法")]),a._v(" "),t("p",[a._v("4 使用反射的方法对类型进行反射调用的时候")]),a._v(" "),t("p",[a._v("5 进行类初始化时，如果父类没有初始化，要先触发其父类的初始化")]),a._v(" "),t("p",[a._v("6 当一个接口中定义了JDK8加入的默认方法，如果有这个接口的实现类发生了初始化，那么接口需要在这之前完成初始化")]),a._v(" "),t("hr"),a._v(" "),t("h1",{attrs:{id:"类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),t("p",[a._v("Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作")]),a._v(" "),t("p",[a._v("放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。")]),a._v(" "),t("p",[a._v("实现这个动作的代码被称为“"),t("strong",[a._v("类加载器")]),a._v("”（Class Loader）。")]),a._v(" "),t("h2",{attrs:{id:"比较两个类是否-相等"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#比较两个类是否-相等"}},[a._v("#")]),a._v(" "),t("strong",[a._v("比较两个类是否“相等”，")])]),a._v(" "),t("p",[a._v("只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个")]),a._v(" "),t("p",[a._v("Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。")]),a._v(" "),t("p",[a._v("“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，")]),a._v(" "),t("p",[a._v("也包括了使用instanceof关键字做对象所属关系判定等各种情况。")]),a._v(" "),t("h2",{attrs:{id:"类加载器-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器-2"}},[a._v("#")]),a._v(" "),t("strong",[a._v("类加载器")])]),a._v(" "),t("p",[a._v("JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：\n1. "),t("strong",[a._v("BootstrapClassLoader(启动类加载器)")]),a._v(" ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。\n2. "),t("strong",[a._v("ExtensionClassLoader(扩展类加载器)")]),a._v(" ：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。\n3. "),t("strong",[a._v("AppClassLoader(应用程序类加载器)")]),a._v(" ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。")]),a._v(" "),t("img",{staticStyle:{zoom:"25%"},attrs:{src:"https://lxzxz-club-myblog.oss-cn-guangzhou.aliyuncs.com/20230515152429.png"}}),a._v(" "),t("h1",{attrs:{id:"双亲委派机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[a._v("#")]),a._v(" 双亲委派机制")]),a._v(" "),t("p",[a._v("​\t其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个Mother ClassLoader和一个Father ClassLoader。")]),a._v(" "),t("p",[a._v('​\t类加载器之间的"父子”关系也不是通过继承来体现的，是由优先级"来决定。官方 API 文档')]),a._v(" "),t("h2",{attrs:{id:"工作过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工作过程"}},[a._v("#")]),a._v(" "),t("strong",[a._v("工作过程：")])]),a._v(" "),t("p",[a._v("如果一个类加载器收到了类加载的请求，它首先把这个请求委派给父类加载器去完成，")]),a._v(" "),t("p",[a._v("每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器(Bootstrap)中，")]),a._v(" "),t("p",[a._v("只有当父类反馈自己无法完成这个加载请求，子加载器才会尝试自己去完成类加载的过程。")]),a._v(" "),t("h2",{attrs:{id:"双亲委派机制的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制的作用"}},[a._v("#")]),a._v(" "),t("strong",[a._v("双亲委派机制的作用：")])]),a._v(" "),t("p",[a._v("使得Java中的类随它的类加载器一起具备了层级关系，")]),a._v(" "),t("p",[a._v("例如Object类，无论哪个类加载器要加载这个类，最终都会被启动类加载器加载，")]),a._v(" "),t("p",[a._v("这样就使得Object类在类加载环境中始终是同一个类，")]),a._v(" "),t("p",[a._v("若没有双亲委派机制的话，我们自己定义一个在java.lang目录下的Object类，那么系统中就会出现多个Object类")])])}),[],!1,null,null,null);t.default=_.exports}}]);