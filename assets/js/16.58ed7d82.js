(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{419:function(v,_,t){"use strict";t.r(_);var o=t(1),s=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[v._v("#")]),v._v(" 垃圾收集器")]),v._v(" "),_("h2",{attrs:{id:"垃圾收集区域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集区域"}},[v._v("#")]),v._v(" 垃圾收集区域")]),v._v(" "),_("p",[v._v("不需要垃圾回收的区域：")]),v._v(" "),_("p",[_("strong",[v._v("程序计数器、虚拟机栈、本地方法栈")]),v._v("3个区域随线程而生，随线程而灭，")]),v._v(" "),_("p",[v._v("栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基")]),v._v(" "),_("p",[v._v("本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，")]),v._v(" "),_("p",[v._v("在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。")]),v._v(" "),_("p",[v._v("需要垃圾回收的区域：")]),v._v(" "),_("p",[v._v("而"),_("strong",[v._v("Java堆和方法区")]),v._v("这两个区域则有着很显著的不确定性：")]),v._v(" "),_("p",[v._v("​\t一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理，")]),v._v(" "),_("p",[v._v("针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种:")]),v._v(" "),_("p",[v._v("部分收集 (Partial GC):")]),v._v(" "),_("ul",[_("li",[v._v("新生代收集（MinorGC/Young GC）：只对新生代进行垃圾收集;")]),v._v(" "),_("li",[v._v("老年代收集（Major GC／Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集;")]),v._v(" "),_("li",[v._v("混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。")])]),v._v(" "),_("p",[v._v("整堆收集 (Full GC)： 收集整个 JaVa 堆和方法区。")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"对象存活判定算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象存活判定算法"}},[v._v("#")]),v._v(" 对象存活判定算法")]),v._v(" "),_("p",[v._v("一个对象被判断为不再使用的对象时，才会进行垃圾回收。")]),v._v(" "),_("p",[_("strong",[v._v("引用计数算法")])]),v._v(" "),_("p",[v._v("​\t  被引用一次，计数器加一，失效一次，计数器减一，为零就是不能再被使用的对象")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("Java没有采用这种算法，如果a，b相互引用 产生对象的循环引用会使对象无法被回收\n")])])]),_("p",[_("strong",[v._v("可达性分析算法")])]),v._v(" "),_("p",[v._v("​\t从GC Roots对象根据引用关系向下搜索，搜索过程中所走过的路径为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再使用的")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://lxzxz-club-myblog.oss-cn-guangzhou.aliyuncs.com/20230515152337.png",alt:""}})]),v._v(" "),_("p",[_("strong",[v._v("可作为 GC Roots 的对象包括下面几种:")])]),v._v(" "),_("ul",[_("li",[v._v("虚拟机栈(栈帧中的本地变量表)中引用的对象")]),v._v(" "),_("li",[v._v("本地方法栈(Native 方法)中引用的对象")]),v._v(" "),_("li",[v._v("方法区中类静态属性引用的对象")]),v._v(" "),_("li",[v._v("方法区中常量引用的对象")]),v._v(" "),_("li",[v._v("所有被同步锁持有的对象")])]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"垃圾收集算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集算法"}},[v._v("#")]),v._v(" 垃圾收集算法")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("标记清除算法（老年代)：")])])]),v._v(" "),_("p",[v._v("​\t1、首先标记出所有需要回收的对象")]),v._v(" "),_("p",[v._v("​\t2、在标记完成后，统一回收掉所有被标记的对象，（会有空间碎片的问题）")]),v._v(" "),_("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://lxzxz-club-myblog.oss-cn-guangzhou.aliyuncs.com/20230515152347.png"}}),v._v(" "),_("ul",[_("li",[_("strong",[v._v("标记复制算法（半区复制）")]),v._v("：优先采用了这种收集算法去回收"),_("strong",[v._v("新生代")])])]),v._v(" "),_("p",[v._v("​\t\t当一块内存用完了就把仍然存活的对象复制到另一块内存， 必然会产生一定空间的浪费，但是不会出现空间碎片的情况")]),v._v(" "),_("p",[v._v("​\t\t为什么HotSpot虚拟机采用8：1：1的比例分区？\n​\t\t根据绝大多数的对象都熬不过第一轮GC，Hotspot采用8：1：1的分配策略，90%的空间为新生代可用内存空间，浪费的是10%")]),v._v(" "),_("p",[v._v("​\t\t但是如果10%的内存不够用时，有逃生门策略来分配对象（逃生门指的是不够空间分配的对象直接到老年代）")]),v._v(" "),_("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://lxzxz-club-myblog.oss-cn-guangzhou.aliyuncs.com/20230515152357.png"}}),v._v(" "),_("ul",[_("li",[v._v("**标记整理算法：**让所有的存活对象都向内存空间的一端移动，然后清理掉边界以外的内存，没有空间碎片的烦恼(要移动对象，效率不高）")])]),v._v(" "),_("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://lxzxz-club-myblog.oss-cn-guangzhou.aliyuncs.com/20230515152403.png"}}),v._v(" "),_("p",[_("strong",[v._v("HotSpot 为什么要分为新生代和老年代？")])]),v._v(" "),_("p",[v._v("​\t根据新生代和老年代，这样我们就可以根据名个年代的特点选择合适的垃圾收集算法。")]),v._v(" "),_("p",[v._v("​\t比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。")]),v._v(" "),_("p",[v._v("​\t而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"经典垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#经典垃圾收集器"}},[v._v("#")]),v._v(" 经典垃圾收集器")]),v._v(" "),_("p",[_("strong",[v._v("young新生代 （标记复制,复制到另一个半区）")])]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("serial收集器")])]),v._v(" "),_("p",[v._v("单线程工作的收集器, 在进行垃圾收集工作的时候必须暂停其他所有的工作线程（Stop The World）")]),v._v(" "),_("p",[v._v("面向年轻代的，采用标记复制算法")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("ParNew")])]),v._v(" "),_("p",[v._v("实际上是Serial的多线程版本，同样是标记复制算法，也需要在垃圾回收的时候Stop the world")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("Parallel Scavenge(JDK1.8默认）")])]),v._v(" "),_("p",[v._v("新生代收集器，基于标记-复制算法，也是多线程收集器，被称作“吞吐量优先收集器”")]),v._v(" "),_("p",[v._v("特别的地方是，有一个可控制的吞吐量")])])]),v._v(" "),_("p",[v._v("---------------------------------------------------------")]),v._v(" "),_("p",[_("strong",[v._v("old老年代（标记整理）")])]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("Serial Old收集器")])]),v._v(" "),_("p",[v._v("serial的老年代版本，采用的是标记整理算法，执行垃圾回收需要Stop the world")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("Parallel Old收集器")])]),v._v(" "),_("p",[v._v("是Parallel Scavenge收集器的老年代版本，支持多线程并行收集，采用标记整理算法，同样也是关注吞吐量")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("CMS收集器（标记清除）")])]),v._v(" "),_("p",[v._v("以获取"),_("strong",[v._v("最短停顿时间")]),v._v("为目标的收集器，基于标记-清除算法实现")]),v._v(" "),_("p",[v._v("分为四个步骤（两停顿、两并发）")])]),v._v(" "),_("li",[_("p",[v._v("1）初始标记（CMS initial mark）：标记GC Roots直接关联的对象，需要Stop the world")])]),v._v(" "),_("li",[_("p",[v._v("2）并发标记（CMS concurrent mark）：从GC Roots直接关联对象 开始遍历能引用到的所有对象，并发")])]),v._v(" "),_("li",[_("p",[v._v("3）重新标记（CMS remark）：对并发标记阶段的标记进行修正，需要Stop the world")])]),v._v(" "),_("li",[_("p",[v._v("4）并发清除（CMS 。concurrent sweep）：将之前标记为已死亡的对象 进行回收，与用户线程并发，")]),v._v(" "),_("p",[v._v("缺点：1、会产生空间碎片，2、无法解决“浮动垃圾”")])])]),v._v(" "),_("p",[v._v("----------------------------------------------")]),v._v(" "),_("p",[v._v("G1")]),v._v(" "),_("p",[_("strong",[v._v("Garbage First收集器")])]),v._v(" "),_("p",[v._v("简称G1，为了替代掉CMS垃圾回收器，JDK9后成为服务端模式下的默认垃圾收集器。")]),v._v(" "),_("p",[v._v("不只是面向新生代或者老年代，")]),v._v(" "),_("p",[v._v("而是面向整个堆并将其划分为各个大小相等的独立区域(Region),每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间，")]),v._v(" "),_("p",[v._v("Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。")]),v._v(" "),_("p",[v._v("G1收集器的运作过程大致可划分为以下四个步骤：（三停顿一并发）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("1 初始标记：标记GC Roots直接关联的对象，需要Stop the world")])]),v._v(" "),_("li",[_("p",[v._v("2 并发标记：从GC Roots直接关联对象 开始遍历能引用到的所有对象，并发 （前两个阶段和CMS基本一致？？？）")])]),v._v(" "),_("li",[_("p",[v._v("3 最终标记：处理并发标记后的修正操作，需要Stop the world")])]),v._v(" "),_("li",[_("p",[v._v("4 筛选回收：对各个Rigion的回收价值进行排序，根据用户期望的停顿时间按计划回收，并将被回收的Region中存活的对象复制到空的Region中，再清理掉旧的Region，需要Stop the world")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);